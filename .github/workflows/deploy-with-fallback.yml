name: Deploy with Fallback to VPS

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy-with-fallback:
    runs-on: ubuntu-latest
    
    steps:
      - name: üì• Checkout code
        uses: actions/checkout@v4

      - name: üîê Setup SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.VPS_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          echo "SSH key saved, first line:"
          head -n 1 ~/.ssh/id_rsa
          echo "VPS Host: ${{ secrets.VPS_HOST }}"
          echo "Adding known hosts..."
          ssh-keyscan -H ${{ secrets.VPS_HOST }} >> ~/.ssh/known_hosts 2>&1 || echo "ssh-keyscan failed, continuing..."
          echo "SSH setup complete"

      - name: üõ†Ô∏è Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: üì¶ Install dependencies
        run: |
          cd backend && npm install
          cd ../frontend && npm install

      - name: üî® Build Backend with Fallback
        id: build-backend
        run: |
          cd backend
          echo "Building backend..."
          
          # Try to build
          if npm run build; then
            echo "‚úÖ Backend build successful"
            echo "backend_status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Backend build failed"
            echo "backend_status=failed" >> $GITHUB_OUTPUT
          fi

      - name: üî® Build Frontend with Fallback
        id: build-frontend
        run: |
          cd frontend
          echo "Building frontend..."
          
          # Try to build
          if npm run build; then
            echo "‚úÖ Frontend build successful"
            echo "frontend_status=success" >> $GITHUB_OUTPUT
          else
            echo "‚ùå Frontend build failed"
            echo "frontend_status=failed" >> $GITHUB_OUTPUT
          fi

      - name: üì¶ Create deployment package
        run: |
          echo "Creating deployment package..."
          # Create archive in /tmp to avoid "file changed as we read it" error
          cd "${{ github.workspace }}"
          tar -czf /tmp/deploy-package.tar.gz \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='node_modules' \
            --exclude='backend/node_modules' \
            --exclude='frontend/node_modules' \
            --exclude='dist' \
            --exclude='*.tar.gz' \
            --exclude='*.log' \
            .
          # Move archive back to workspace
          mv /tmp/deploy-package.tar.gz ./deploy-package.tar.gz
          echo "‚úÖ Deployment package created"

      - name: üì§ Upload to VPS
        run: |
          echo "Uploading to VPS..."
          scp -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o ConnectTimeout=30 -o TCPKeepAlive=yes deploy-package.tar.gz ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }}:/tmp/
          echo "‚úÖ Files uploaded to VPS"
          
          # Small delay to avoid connection reset issues
          sleep 2

      - name: üîß Deploy on VPS with Fallback
        env:
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          MYSQL_ROOT_PASSWORD: ${{ secrets.MYSQL_ROOT_PASSWORD }}
          MYSQL_DATABASE: ${{ secrets.MYSQL_DATABASE }}
          MYSQL_USER: ${{ secrets.MYSQL_USER }}
          MYSQL_PASSWORD: ${{ secrets.MYSQL_PASSWORD }}
          SMTP_HOST: ${{ secrets.SMTP_HOST }}
          SMTP_PORT: ${{ secrets.SMTP_PORT }}
          SMTP_USER: ${{ secrets.SMTP_USER }}
          SMTP_PASS: ${{ secrets.SMTP_PASS }}
        run: |
          ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o ConnectTimeout=30 -o TCPKeepAlive=yes ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
            set -e
            
            echo "üöÄ Starting deployment with fallback mechanism..."

            BACKUP_ROOT=~/.coffe-backups
            mkdir -p "$BACKUP_ROOT"

            # Create backup before we wipe the project directory
            if [ -d ~/coffe ]; then
              TS=$(date +%Y%m%d_%H%M%S)
              BACKUP_FILE="$BACKUP_ROOT/backup-$TS.tar.gz"
              echo "üì¶ Creating backup of current deployment -> $BACKUP_FILE"
              tar -czf "$BACKUP_FILE" \
                --exclude='./node_modules/*' \
                --exclude='./frontend/node_modules/*' \
                --exclude='./backend/node_modules/*' \
                -C ~/coffe .
              echo "‚úÖ Backup saved"
            else
              echo "‚ÑπÔ∏è No existing deployment directory, skipping backup"
            fi

            echo "üß® FULL CLEANUP: stopping and removing all docker resources and project directory"
            # Stop and remove all containers (no-fail if none)
            docker ps -aq | xargs -r docker stop || true
            docker ps -aq | xargs -r docker rm -f || true
            # Remove networks/volumes/images caches that may conflict
            docker network prune -f || true
            docker volume prune -f || true
            docker system prune -af || true
            # Remove project directory entirely
            rm -rf ~/coffe || true
            mkdir -p ~/coffe
            
            # Extract new deployment
            echo "üì¶ Extracting new deployment (staged)..."
            STAGE_DIR=/tmp/deploy-stage-$(date +%s)
            mkdir -p "$STAGE_DIR"
            tar -xzf /tmp/deploy-package.tar.gz -C "$STAGE_DIR" --no-same-owner --no-same-permissions
            rm -f /tmp/deploy-package.tar.gz

            # Sync ALL staged files into target to ensure backend/ and frontend/ exist
            mkdir -p ~/coffe
            rsync -a "$STAGE_DIR"/ ~/coffe/
            rm -rf "$STAGE_DIR"

            # Ensure required directories exist
            mkdir -p ~/coffe/scripts ~/coffe/docker ~/coffe/docker/mysql
            
            # Ensure init.sql exists (create empty if missing)
            if [ ! -f ~/coffe/docker/mysql/init.sql ]; then
              echo "-- MySQL initialization script" > ~/coffe/docker/mysql/init.sql
              echo "SELECT 'Database initialized';" >> ~/coffe/docker/mysql/init.sql
            fi

            # Create .env from CI secrets if missing
            if [ ! -f ~/coffe/.env ]; then
              echo -e "JWT_SECRET=${JWT_SECRET}\nMYSQL_ROOT_PASSWORD=${MYSQL_ROOT_PASSWORD}\nMYSQL_DATABASE=${MYSQL_DATABASE}\nMYSQL_USER=${MYSQL_USER}\nMYSQL_PASSWORD=${MYSQL_PASSWORD}\nSMTP_HOST=${SMTP_HOST}\nSMTP_PORT=${SMTP_PORT}\nSMTP_USER=${SMTP_USER}\nSMTP_PASS=${SMTP_PASS}" > ~/coffe/.env
            fi

            # Ensure Dockerfiles exist with expected names
            if [ -f ~/coffe/backend/Dockerfile.fallback ]; then
              cp -f ~/coffe/backend/Dockerfile.fallback ~/coffe/backend/Dockerfile
            fi
            if [ -f ~/coffe/frontend/Dockerfile.fallback ]; then
              cp -f ~/coffe/frontend/Dockerfile.fallback ~/coffe/frontend/Dockerfile
            fi

            # Decide compose command (prefer v2)
            if docker compose version >/dev/null 2>&1; then
              COMPOSE="docker compose"
            else
              COMPOSE="docker-compose"
            fi
            
            # Stop current containers and force remove all project containers
            echo "üõë Stopping and removing all containers..."
            cd ~/coffe
            
            # Force remove all containers by name (including orphans)
            docker ps -a --format "{{.Names}}" | grep -E "(coffee_|coffe_)" | xargs -r docker rm -f || true
            
            # Use compose down if possible
            $COMPOSE -f docker-compose.fallback.yml down -v --remove-orphans 2>/dev/null || true
            
            # Clean old images and networks
            echo "üßπ Cleaning old images and networks..."
            docker image prune -af || true
            docker network ls -q --filter name=coffee_fallback | xargs -r docker network rm || true
            docker network ls -q --filter name=coffe_ | xargs -r docker network rm || true
            
            # Build and start with fallback
            echo "üèóÔ∏è Pulling base images..."
            cd ~/coffe && $COMPOSE -f docker-compose.fallback.yml pull || true
            
            echo "üèóÔ∏è Building and starting with fallback..."
            cd ~/coffe && $COMPOSE -f docker-compose.fallback.yml up -d --build --force-recreate --remove-orphans
            
            # Wait for MySQL to start and check status
            echo "‚è≥ Waiting for MySQL to initialize..."
            sleep 10
            
            # Check all containers status first
            echo "üìä All containers status:"
            docker ps -a --filter "name=coffee_" --format "table {{.Names}}\t{{.Status}}\t{{.ExitCode}}" || true
            
            # Check system resources
            echo "üíæ Disk space:"
            df -h / || true
            echo "üß† Memory:"
            free -h || true
            
            if ! docker ps | grep -q coffee_mysql_fallback; then
              echo "‚ùå MySQL container failed to start. Detailed diagnostics:"
              echo "üìã MySQL logs (last 100 lines):"
              docker logs coffee_mysql_fallback --tail=100 2>&1 || true
              echo "üìã MySQL container inspect (State section):"
              docker inspect coffee_mysql_fallback 2>&1 | grep -A 30 '"State"' || true
              echo "üíæ Volume info:"
              docker volume inspect coffe_mysql_data 2>&1 || true
              exit 1
            fi
            
            # Check MySQL health
            for i in {1..30}; do
              if docker exec coffee_mysql_fallback mysqladmin ping -h localhost -u root -prootpassword >/dev/null 2>&1; then
                echo "‚úÖ MySQL is healthy"
                break
              fi
              echo "‚è≥ Waiting for MySQL health check (attempt $i/30)..."
              sleep 2
            done
            
            echo "‚úÖ Deployment completed"
          EOF

      - name: ‚è≥ Wait for services to start
        run: sleep 30

      - name: üîç Health Check Backend
        id: health-backend
        run: |
          echo "Checking backend health..."
          
          # Wait for backend to be ready
          for i in {1..10}; do
            if curl -f --max-time 10 "http://${{ secrets.VPS_HOST }}:3001/api/health" &> /dev/null; then
              echo "‚úÖ Backend is healthy"
              echo "backend_health=healthy" >> $GITHUB_OUTPUT
              break
            else
              echo "‚è≥ Backend not ready yet, attempt $i/10..."
              sleep 10
            fi
          done
          
          if [ "$backend_health" != "healthy" ]; then
            echo "‚ùå Backend health check failed"
            echo "backend_health=unhealthy" >> $GITHUB_OUTPUT
          fi

      - name: üîç Health Check Frontend
        id: health-frontend
        run: |
          echo "Checking frontend health..."
          
          # Wait for frontend to be ready
          for i in {1..10}; do
            if curl -f --max-time 10 "http://${{ secrets.VPS_HOST }}:4000" &> /dev/null; then
              echo "‚úÖ Frontend is healthy"
              echo "frontend_health=healthy" >> $GITHUB_OUTPUT
              break
            else
              echo "‚è≥ Frontend not ready yet, attempt $i/10..."
              sleep 10
            fi
          done
          
          if [ "$frontend_health" != "healthy" ]; then
            echo "‚ùå Frontend health check failed"
            echo "frontend_health=unhealthy" >> $GITHUB_OUTPUT
          fi

      - name: üîÑ Rollback if Health Check Failed
        if: steps.health-backend.outputs.backend_health == 'unhealthy' || steps.health-frontend.outputs.frontend_health == 'unhealthy'
        run: |
          echo "üîÑ Health check failed, attempting rollback..."
          
          ssh -o StrictHostKeyChecking=no -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -o ConnectTimeout=30 -o TCPKeepAlive=yes ${{ secrets.VPS_USER }}@${{ secrets.VPS_HOST }} << 'EOF'
            set -e
            
            echo "üîÑ Starting rollback process..."
            
            # Find the most recent backup
            BACKUP_ROOT=~/.coffe-backups
            LATEST_BACKUP=$(ls -t "$BACKUP_ROOT"/backup-*.tar.gz 2>/dev/null | head -n 1)
            
            if [ -n "$LATEST_BACKUP" ]; then
              echo "üì¶ Restoring from backup: $LATEST_BACKUP"
              
              # Stop current containers and remove orphans/volumes/images
              cd ~/coffe || exit 1
              docker-compose -f docker-compose.fallback.yml down -v --rmi all --remove-orphans || true
              docker ps -aq --filter "name=coffee_mysql_fallback" | xargs -r docker rm -f || true
              docker ps -aq --filter "name=coffe_mysql" | xargs -r docker rm -f || true
              docker volume ls -q --filter name=coffe_ | xargs -r docker volume rm || true
              docker network ls -q --filter name=coffe_ | xargs -r docker network rm || true
              
              # Restore from backup
              tar -xzf "$LATEST_BACKUP" -C ~/coffe --overwrite --no-same-owner --no-same-permissions

              # Ensure we are in the correct directory and compose file exists
              cd ~/coffe || exit 1
              if [ ! -f "docker-compose.fallback.yml" ]; then
                echo "‚ùå docker-compose.fallback.yml not found after restore. Listing directory:"
                ls -la
                exit 1
              fi
              
              # Start with restored version
              docker-compose -f docker-compose.fallback.yml up -d --remove-orphans
              
              echo "‚úÖ Rollback completed"
            else
              echo "‚ùå No backup found for rollback"
              exit 1
            fi
          EOF

      - name: üîç Final Health Check
        run: |
          echo "Performing final health check..."
          
          # Wait a bit for rollback to complete
          sleep 20
          
          # Check backend
          if curl -f --max-time 10 "http://${{ secrets.VPS_HOST }}:3001/api/health" &> /dev/null; then
            echo "‚úÖ Backend is healthy after rollback"
          else
            echo "‚ùå Backend is still unhealthy"
            exit 1
          fi
          
          # Check frontend
          if curl -f --max-time 10 "http://${{ secrets.VPS_HOST }}:4000" &> /dev/null; then
            echo "‚úÖ Frontend is healthy after rollback"
          else
            echo "‚ùå Frontend is still unhealthy"
            exit 1
          fi

      - name: üìä Deployment Status
        run: |
          echo "üéâ Deployment with fallback completed successfully!"
          echo "Backend: http://${{ secrets.VPS_HOST }}:3001"
          echo "Frontend: http://${{ secrets.VPS_HOST }}:4000"
          echo "Health Check: http://${{ secrets.VPS_HOST }}:3001/api/health"

      - name: üßπ Cleanup
        if: always()
        run: |
          rm -f deploy-package.tar.gz
          echo "‚úÖ Cleanup completed"
